# DSZI-Autonomic-Grim-Reaper

### Autorzy: Zofia Dobrowolska, Maciej Grochowski, Katarzyna Makohon

"Autonomiczna Kostucha" jest agentem poruszającym się po dwuwymiarowym środowisku. Jej zadaniem jest selekcjonowanie osób, które powinna zabić, oraz ustalenie optymalnej trasy, która pozwoli jej efektywnie wypełniać swoja rolę. Kostucha podejmuje decyzje, co do tego kogo i w jakiej kolejności zabić na podstawie cech indywidualnych osób (np. wiek)

___

### Autonomic-Grim-Reaper - Podprojekt indywidualny - Algorytm Genetyczny

**Katarzyna Makohon**

Data: 19.05.2019

---

**1. Wstęp**

W tym przyroście zaimplementowałam algorytm genetyczny, który ma stworzyć najbardziej optymalną drogę dla agenta. Jest to rozwiązanie problemu komiwojażera określające listę kolejnych ludzi, któych ma odwiedzić kostucha. Przy zetknięciu się z człowiekiem agent ocenia (z pomocą drzewa decyzyjnego i sieci neuronowej zaprezentowanej w poprzednich przyrostach) czy postać przed nią jest człowiekiem, oraz czy zasługuje ona na śmierć. 

---

**2. Zmiany**

- Powstał nowy folder GA, w którym znajduje się nowy plik GenAl.py

- Powstał nowy plik GenAl.py, który zawiera implementację czterech nowych klas (TourManager, Tour, Population i GA) razem implementujących algorytm genetyczny. 

- Znajdujący się w pliku aStar algorytm Astar został przepisany z użyciem implementacji kolejki priorytetowej dostarczanej przez moduł Heapq. 

- Osoby zyskały nową zmienną (słownik wypełniany w momencie wywołania metody checkAllDistance()) z poziomu TourManagera) oraz metodę DistanceTo() pozwalającą wyliczyć dystans od zadanej osoby.

- Zmianie uległ sposób generowania ludzi. Na potrzeby prezentacji na mapie ustawiono na sztywno 6 osób klasyfikowanych przez nas jako "boy".

- Dodano funkcję AstarWithReaper() pozwalającą określić do którego z ludzi znajdujących sie na planszy agent dotrze drogą o najniższym koszcie, aby to od niego realizować drogę opracowaną przez algorytm genetyczny. 

- Algorytm Genetyczny zostanie wywołany po naciśnięciu klawisza spacji.

----

**3. Algorytm Genetyczny**

Algorytm genetyczny zamiast rozwiązywać problem analitycznie stara się uzyskać jak najlepsze rozwiązania poprzez wybieranie określonych rozwiązań z zadanej puli początkowej i krzyżowanie ich ze sobą. 

*Sposób działania algorytmu:*

1. Wybieramy populację początkową.  

   W moim przypadku każdy osobnik tej populacji jest obiektem klasy Tour, gdzie obiekt taki zawiera tablicę osób, które pojawiły się na planszy wraz z agentem. Generuję populację złożoną z osobników, które są permutacjami tablicy, którą zawiera obiekt Tour. 

2. Ewoluujemy populację. 

   Podczas ewolucji z obecnej populacji powstaje nowa populacja przy równoczesnym zastosowaniu dwóch technik.

   - Krzyżowanie

     W moim przypadku polega na wybraniu z populacji dwójki rodziców i przemieszanie ich cech tworząc potomka. Odbywa się to przy pomocy funkcji crossover(), która losuje dwie liczby z zakresu od 0 do rozmiaru Tour, a następnie umieszcza w nowym osobniku geny jednego z rodziców gdy odpowiadają im miejsca tablicy wewnątrz tego wyznaczonego zakresu. Resztę genów osobnik dziedziczy po drugim z rodziców.

   - Mutacja

     Polega na zamianie miejscami genów. W moim przypadku dla każdego genu losuję liczbę i jeżeli jest ona mniejsza, niż ustalony współczynnik mutacji to wybrany gen zostaje zamieniony miejscami z innym wylosowanym genem. Szansę na mutację ma każdy kolejny gen w Tourze. 

3. Wybieramy najlepsze osobniki. 

   - Ocena jakości

     Za funkcję oceny jakości posłużył mi algorytm A* zaimplementowany w jednym z poprzednich przyrostów. Wraz z odpowiednią strukturą zdefiniowaną w każdej osobie, oraz przy pomocy funkcji pomocniczej checkAllDistance() obliczam koszt ogólny przejścia po kolei do osób zdefiniowanych jako kolejne obiekty w tablicy Tour.

   - Selekcja

     Celem selekcji jest ograniczenie zbioru do najlepszych osobników, tak aby wyeliminować z populacji rozwiązania słabe i nieefektywne, a pozostawienie dobrych podlegających dalszemu krzyżowaniu. W moim przypadku funkcja tournamentSelection() jest aktywowana w momencie dokonywania wyboru odnośnie rodziców przy krzyżowaniu. 

4. Warunek stopu

   Warunkiem stopu wielu algorytmów jest osiągnięcie zadowalajacego wyniku funkcji oceny jakości w przypadku komuwojażera jednak nie da się przewidzieć najbardziej optymalnej trasy, a co za tym idzie nie można narzucić warunku tego typu. Zamiast tego ograniczyłam ilość ewolucji do 100 uznając, że wynik otrzymany w tym czasie będzie zadowalający, chociaż niekoniecznie optymalny. 

   ---
































































































































































































































































































































































































































































































































































